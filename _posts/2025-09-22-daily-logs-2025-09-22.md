---
layout: post
title: Daily Logs for Sep 22, 2025 
author: tushar sharma
image: https://bing.com//th?id=OHR.AspenEquinox_EN-US8237887036_1920x1080.jpg&pid=hp&w=437
thumb: https://bing.com//th?id=OHR.AspenEquinox_EN-US8237887036_1920x1080.jpg&pid=hp&w=437
category: blog
tags:
 - java
 - letters
---

Dear Vishi, dear logs for today.<!-- truncate_here -->

Dear Vishi, dear logs for today.

## Spring Boot Startup Lifecycle

* Spring Boot has IoC (Inversion of Control) container that manages all the bean initialization. This is also called dependency injection ‚Äî it creates beans, wires them together, and keeps them alive for you.

* Next Spring Boot calls lifecycle hooks like `PostConstruct`, `BeanPostProcessor`, `InitializingBean`

* `PostConstruct` runs once per bean, right after its dependencies are set. It's NOT global ‚Äî each bean gets its own `PostConstruct` moment.

* After `PostConstruct` and post-processing, Spring fires the `ContextRefreshedEvent`. This is fired when **Application Context** is fully loaded.

* Right after that, if you have any `CommandLineRunner` beans, Spring runs them ‚Äî in order, if you used **Order**. This is your last chance to run code before the server starts.

* If you have any beans that implement **SmartLifecycle (and isAutoStartup() returns true)**, Spring will call their start() method right after ContextRefreshedEvent but BEFORE the server starts ‚Äî basically around the same time as CommandLineRunner, but you can control the order with getPhase().

* THEN ‚Äî and only then ‚Äî Spring starts the embedded server (Tomcat, Netty, etc). It binds to the port (like 8080), starts threads, and gets ready to accept requests.

* Once the server is up and the app is truly ready to serve traffic (and health checks are green, if you‚Äôre using them), Spring fires the **ApplicationReadyEvent**. This is the ‚Äúgreen light‚Äù ‚Äî your app is LIVE.

### When to Use What?

| Hook / Event             | Vibe üí¨                                      | Best For                                      |
|--------------------------|----------------------------------------------|-----------------------------------------------|
| `@PostConstruct`         | "I‚Äôm a bean ‚Äî I‚Äôm setting up **MYSELF**."     | Bean-specific init: open connection, load config, validate deps |
| `SmartLifecycle`         | "I‚Äôm a background worker ‚Äî start me when the app is ready, **but before traffic**." | Long-running services: pollers, listeners, async processors (with graceful stop) |
| `CommandLineRunner`      | "I‚Äôm a **script** ‚Äî run me **once**, after everything‚Äôs wired, **before the server opens**." | One-time setup: preload data, print args, warm cache, send startup log |
| `ApplicationReadyEvent`  | "**Server is live** ‚Äî now do your final thing." | Final go-live tasks: call health endpoints, notify Slack, start polling external APIs |

## Flux.Iterable in Java Reactive

Both of these are equivalent

```java
Flux<String> foo = Flux.just("cat", "dog");
Flux<String> bar = Flux.fromIterable(List.of("cat", "dog"));

foo.subscribe(System.out::println);
bar.subscribe(System.out::println);
```

For small fixed values, `Flux.just` is fine. When working with an existing collection or a large list, prefer `Flux.fromIterable`, since `Flux.just` is not designed to take a collection directly and can lead to performance issues if used that way.
---
layout: post
title: Custom Key Namespacing in Valkey / Redis
image: https://unsplash.com/photos/KrYbarbAx5s/download?w=437
thumb: https://unsplash.com/photos/KrYbarbAx5s/download?w=437
author: tushar sharma
category: blog
tags:
 - redis
 - valkey
 - spring boot
---

With Redis transitioning to a commercial model, many projects are turning to alternatives like Valkey—a forked Redis variant aimed at maintaining open-source availability. Here, we implement a Valkey-based key-value store with automatic application-scoped key namespacing in a Spring Boot application.<!-- truncate_here -->

## Requirements

We need two endpoints for setting and getting key-value pairs:

POST /valkey/set — stores a key-value pair in Valkey.

GET /valkey/get?key=<key> — retrieves the value for a specified key.

In Valkey, keys are stored with an application-specific prefix to avoid collisions across services, e.g., appID:testKey instead of just testKey. The application name, defined in application.properties, should be automatically prepended to each key.

## Spring Boot Implementation

We use Spring Boot's ReactiveRedisTemplate to integrate with Valkey. By leveraging a BeanPostProcessor, we can add the application prefix to every key transparently without modifying the core application code.

### ValkeyController

The ValkeyController defines two endpoints for set and get operations. Each endpoint delegates to ValkeyService, which interacts with ReactiveRedisTemplate for Valkey operations.

<div style="display:none;" markdown="1">
@RestController
@RequestMapping(value = "/valkey")
public class ValkeyController {
    private final ValkeyService valkeyService;

    public ValkeyController(ValkeyService valkeyService) {
        this.valkeyService = valkeyService;
    }


    @PostMapping("/set")
    public Mono<ResponseEntity<Boolean>> set(@RequestBody Map<String, String> requestBody) {

        return valkeyService.setValue(requestBody.get("key"), requestBody.get("value"))
                .map(result -> ResponseEntity.ok().body(result))
                .defaultIfEmpty(ResponseEntity.badRequest().build());
    }

    @GetMapping("/get")
    public Mono<ResponseEntity<String>> get(@RequestParam String key) {

        return valkeyService.getValue(key)
                .map(value -> ResponseEntity.ok().body(value))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyController.java
---
{% endtemplate %}

### ValkeyService

ValkeyService interacts directly with ReactiveRedisTemplate, implementing setValue and getValue operations.

<div style="display:none;" markdown="1">
@Service
public class ValkeyService {
    private final ReactiveRedisTemplate<String, String> reactiveRedisTemplate;
    
    public ValkeyService(ReactiveRedisTemplate<String, String> reactiveRedisTemplate) {
        this.reactiveRedisTemplate = reactiveRedisTemplate;
    }

    public Mono<Boolean> setValue(String key, String value) {
        return reactiveRedisTemplate.opsForValue().set(key, value);
    }

    public Mono<String> getValue(String key) {
        return reactiveRedisTemplate.opsForValue().get(key);
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyService.java
---
{% endtemplate %}

### Key Prefixing with BeanPostProcessor

To add an application prefix to each key, we create a BeanPostProcessor that intercepts and customizes the ReactiveRedisTemplate bean. By creating a wrapper class PrefixedReactiveRedisTemplate, we ensure every key operation includes the prefix automatically.

<div style="display:none;" markdown="1">
public class ValkeyBeanPostProcessor implements BeanPostProcessor {

    private final String keyPrefix;

    public ValkeyBeanPostProcessor(Environment environment) {
        this.keyPrefix = environment.getProperty("spring.application.name");
    }

    @Override
    public Object postProcessAfterInitialization(@NonNull Object bean, @NonNull String beanName) throws BeansException {

        if (bean instanceof ReactiveRedisTemplate) {
            return new ValkeyBeanPostProcessor.PrefixedReactiveRedisTemplate((ReactiveRedisTemplate<Object,Object >) bean, keyPrefix);
        }

        return bean;
    }

    static class PrefixedReactiveRedisTemplate extends ReactiveRedisTemplate<Object, Object> {

        private final ReactiveRedisTemplate<Object, Object> delegate;

        private final String keyPrefix;

        public PrefixedReactiveRedisTemplate(ReactiveRedisTemplate<Object, Object> delegate, String keyPrefix) {
            super(delegate.getConnectionFactory(), delegate.getSerializationContext());
            this.delegate = delegate;
            this.keyPrefix = keyPrefix;
        }

        String applyPrefix(Object key) {

            if (key instanceof String) {
                return keyPrefix + ":" + key;
            } else {
                throw new IllegalArgumentException("Key must be a String");
            }
        }

        @Override
        public @NonNull ReactiveValueOperations<Object, Object> opsForValue() {

            ReactiveValueOperations<Object, Object> originalOps = delegate.opsForValue();

            return new ReactiveValueOperations<>() {

                @Override
                public @NonNull Mono<Boolean> set(@NonNull Object key, @NonNull Object value) {
                    return originalOps.set(applyPrefix(key), value);
                }

                @Override
                public @NonNull Mono<Boolean> set(@NonNull Object key, @NonNull Object value, @NonNull Duration timeout) {
                    return originalOps.set(applyPrefix(key), value, timeout);
                }

                @Override
                public @NonNull Mono<Boolean> setIfAbsent(@NonNull Object key, @NonNull Object value) {
                    return originalOps.setIfAbsent(applyPrefix(key), value);
                }

                @Override
                public @NonNull Mono<Boolean> setIfAbsent(@NonNull Object key,@NonNull Object value,@NonNull Duration timeout) {
                    return originalOps.setIfAbsent(applyPrefix(key), value, timeout);
                }

                @Override
                public @NonNull Mono<Boolean> setIfPresent(@NonNull Object key,@NonNull Object value) {
                    return originalOps.setIfPresent(applyPrefix(key), value);
                }

                @Override
                public @NonNull Mono<Boolean> setIfPresent(@NonNull Object key,@NonNull Object value,@NonNull Duration timeout) {
                    return originalOps.setIfPresent(applyPrefix(key), value, timeout);
                }

                @Override
                public @NonNull Mono<Boolean> multiSet(@NonNull Map<?, ?> map) {
                    return originalOps.multiSet(map);
                }

                @Override
                public @NonNull Mono<Boolean> multiSetIfAbsent(@NonNull Map<?, ?> map) {
                    return originalOps.multiSetIfAbsent(map);
                }

                @Override
                public @NonNull Mono<Object> get(@NonNull Object key) {
                    return originalOps.get(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Object> getAndDelete(@NonNull Object key) {
                    return originalOps.getAndDelete(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Object> getAndExpire(@NonNull Object key,@NonNull Duration timeout) {
                    return originalOps.getAndExpire(applyPrefix(key), timeout);
                }

                @Override
                public @NonNull Mono<Object> getAndPersist(@NonNull Object key) {
                    return originalOps.getAndPersist(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Object> getAndSet(@NonNull Object key,@NonNull Object value) {
                    return originalOps.getAndSet(applyPrefix(key), value);
                }

                @Override
                public @NonNull Mono<List<Object>> multiGet(@NonNull Collection<Object> keys) {
                    return originalOps.multiGet(keys);
                }

                @Override
                public @NonNull Mono<Long> increment(@NonNull Object key) {
                    return originalOps.increment(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Long> increment(@NonNull Object key,@NonNull long delta) {
                    return originalOps.increment(applyPrefix(key), delta);
                }

                @Override
                public @NonNull Mono<Double> increment(@NonNull Object key,@NonNull double delta) {
                    return originalOps.increment(applyPrefix(key), delta);
                }

                @Override
                public @NonNull Mono<Long> decrement(@NonNull Object key) {
                    return originalOps.decrement(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Long> decrement(@NonNull Object key,@NonNull long delta) {
                    return originalOps.decrement(applyPrefix(key), delta);
                }

                @Override
                public @NonNull Mono<Long> append(@NonNull Object key,@NonNull String value) {
                    return originalOps.append(applyPrefix(key), value);
                }

                @Override
                public @NonNull Mono<String> get(@NonNull Object key,@NonNull long start,@NonNull long end) {
                    return originalOps.get(applyPrefix(key), start, end);
                }

                @Override
                public @NonNull Mono<Long> set(@NonNull Object key,@NonNull Object value,@NonNull long offset) {
                    return originalOps.set(applyPrefix(key), value, offset);
                }

                @Override
                public @NonNull Mono<Long> size(@NonNull Object key) {
                    return originalOps.size(applyPrefix(key));
                }

                @Override
                public @NonNull Mono<Boolean> setBit(@NonNull Object key, long offset, boolean value) {
                    return originalOps.setBit(applyPrefix(key), offset, value);
                }

                @Override
                public @NonNull Mono<Boolean> getBit(@NonNull Object key, long offset) {
                    return originalOps.getBit(applyPrefix(key), offset);
                }

                @Override
                public @NonNull Mono<List<Long>> bitField(@NonNull Object key,@NonNull BitFieldSubCommands command) {
                    return originalOps.bitField(applyPrefix(key), command);
                }

                @Override
                public @NonNull Mono<Boolean> delete(@NonNull Object key) {
                    return originalOps.delete(applyPrefix(key));
                }

            };
        }
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyBeanPostProcessor.java
---
{% endtemplate %}



## AutoConfiguration class

To streamline Valkey integration, we can use an AutoConfiguration class to define beans that configure SSL and key prefixing behavior automatically. This way, Spring Boot will inject the necessary configurations based on the environment settings, improving maintainability and reducing the need for manual setup in each application.

The ValkeyAutoConfiguration class allows us to automatically configure Valkey-related components, such as enabling SSL with custom peer verification settings and injecting the ValkeyBeanPostProcessor for automatic key prefixing.

<div style="display:none;" markdown="1">
@AutoConfigureAfter(value = {RedisReactiveAutoConfiguration.class})
@EnableConfigurationProperties(RedisProperties.class)
@ConditionalOnClass(ReactiveRedisTemplate.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
public class ValkeyAutoConfiguration {

    @Bean
    @ConditionalOnProperty(name = "spring.data.redis.ssl.enabled", havingValue = "true")
    public LettuceClientConfigurationBuilderCustomizer lettuceClientConfigurationBuilderCustomizer() {
        return clientConfigurationBuilder -> clientConfigurationBuilder.useSsl().disablePeerVerification();
    }

    @Bean
    public ValkeyBeanPostProcessor valkeyBeanPostProcessor(Environment environment) {
        return new ValkeyBeanPostProcessor(environment);
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyAutoConfiguration.java
---
{% endtemplate %}

## Integration Test

We can verify that ValkeyAutoConfiguration correctly configures Valkey as a namespaced Redis solution, using the application name as a prefix for keys. The test suite uses Spring Boot’s @SpringBootTest with Testcontainers to simulate a real Valkey environment, ensuring that our configuration works as expected.

<div style="display:none;" markdown="1">
@SpringBootTest(classes = {
        RedisAutoConfiguration.class,
        RedisReactiveAutoConfiguration.class,
        ValkeyAutoConfiguration.class},
        properties = {
                "spring.main.web-application-type=reactive",
                "spring.data.redis.ssl.enabled=false",
                "spring.application.name=appID"
})
@Testcontainers
public class ValkeyAutoConfigurationIntegrationTest {

    @Autowired
    private ReactiveRedisTemplate<String, String> reactiveRedisTemplate;

    @Value("${spring.application.name}")
    private String applicationName;

    @Container
    private static final GenericContainer<?> valkeyContainer = new GenericContainer<>(DockerImageName.parse("valkey/valkey:latest"))
            .withExposedPorts(6379)
            .withStartupAttempts(5)
            .withStartupTimeout(Duration.ofMinutes(5))
            .waitingFor(Wait.forListeningPort());

    @BeforeAll
    public static void beforeAll() {
        valkeyContainer.start();
        System.out.println("Host is " + valkeyContainer.getHost());
        System.out.println("Port is " + valkeyContainer.getFirstMappedPort());
        valkeyContainer.followOutput(System.out::println);
    }

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", valkeyContainer::getHost);
        registry.add("spring.data.redis.port", valkeyContainer::getFirstMappedPort);
    }

    @Test
    void testRedisBeanExists() {
        assertNotNull(reactiveRedisTemplate);
    }

    @Test
    void testInsertAndRetrieveData() {
        String key = "testKey";
        String value = "testValue";

        StepVerifier.create(reactiveRedisTemplate.opsForValue().set(key, value))
                .expectNext(true)
                .verifyComplete();

        StepVerifier.create(reactiveRedisTemplate.opsForValue().get(key))
                .expectNext(value)
                .verifyComplete();

        StepVerifier.create(reactiveRedisTemplate.keys(applicationName + "*"))
                .expectNextMatches(foundKey -> foundKey.equals(applicationName + ":" + key))
                .verifyComplete();
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyAutoConfiguration.java
---
{% endtemplate %}

## Unit Test

<div style="display:none;" markdown="1">
class ValkeyBeanPostProcessorTest {

    @Mock
    private Environment environment;

    @Mock
    private ReactiveRedisTemplate<Object, Object> reactiveRedisTemplate;

    @Mock
    private RedisSerializationContext<Object, Object> redisSerializationContext;

    @Mock
    private ReactiveValueOperations<Object, Object> reactiveValueOperations;

    @Mock
    private ReactiveRedisConnectionFactory reactiveRedisConnectionFactory;

    @InjectMocks
    private ValkeyBeanPostProcessor valkeyBeanPostProcessor;

    private ValkeyBeanPostProcessor.PrefixedReactiveRedisTemplate prefixedTemplate;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        when(environment.getProperty("spring.application.name")).thenReturn("testApp");
        when(reactiveRedisTemplate.opsForValue()).thenReturn(reactiveValueOperations);
        when(reactiveRedisTemplate.getConnectionFactory()).thenReturn(reactiveRedisConnectionFactory);
        when(reactiveRedisTemplate.getSerializationContext()).thenReturn(redisSerializationContext);

        prefixedTemplate = new ValkeyBeanPostProcessor.PrefixedReactiveRedisTemplate(reactiveRedisTemplate, "testApp");
    }

    @Test
    void testPostProcessAfterInitializationWithReactiveRedisTemplate() {
        Object result = valkeyBeanPostProcessor.postProcessAfterInitialization(reactiveRedisTemplate, "reactiveRedisTemplate");
        assertThat(result).isInstanceOf(ValkeyBeanPostProcessor.PrefixedReactiveRedisTemplate.class);
    }

    @Test
    void testPostProcessAfterInitializationWithNonReactiveRedisTemplate() {
        Object bean = new Object();
        Object result = valkeyBeanPostProcessor.postProcessAfterInitialization(bean, "nonRedisTemplate");

        assertThat(result).isSameAs(bean);
    }

    @Test
    void testApplyPrefixWithNonStringKey() {
        assertThatThrownBy(() -> prefixedTemplate.applyPrefix(123))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("Key must be a String");
    }

    @Test
    void testOpsForValueSetWithPrefix() {
        when(reactiveValueOperations.set(eq("testApp:testKey"), eq("testValue"))).thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().set("testKey", "testValue");

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).set(eq("testApp:testKey"), eq("testValue"));
    }

    @Test
    void testOpsForValueSetWithTimeout() {
        Duration timeout = Duration.ofSeconds(30);
        when(reactiveValueOperations.set(eq("testApp:testKey"), eq("testValue"), eq(timeout)))
                .thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().set("testKey", "testValue", timeout);

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).set(eq("testApp:testKey"), eq("testValue"), eq(timeout));
    }

    @Test
    void testOpsForValueGetWithPrefix() {
        when(reactiveValueOperations.get(eq("testApp:testKey"))).thenReturn(Mono.just("testValue"));

        Mono<Object> result = prefixedTemplate.opsForValue().get("testKey");

        StepVerifier.create(result)
                .expectNext("testValue")
                .verifyComplete();

        verify(reactiveValueOperations).get(eq("testApp:testKey"));
    }

    @Test
    void testOpsForValueMultiSetWithPrefix() {
        Map<String, String> values = Map.of("key1", "value1", "key2", "value2");
        when(reactiveValueOperations.multiSet(anyMap())).thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().multiSet(values);

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).multiSet(eq(values));
    }

    @Test
    void testOpsForValueSetIfAbsentWithPrefix() {
        when(reactiveValueOperations.setIfAbsent(eq("testApp:testKey"), eq("testValue"))).thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().setIfAbsent("testKey", "testValue");

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).setIfAbsent(eq("testApp:testKey"), eq("testValue"));
    }

    @Test
    void testOpsForValueSetIfPresentWithPrefix() {
        when(reactiveValueOperations.setIfPresent(eq("testApp:testKey"), eq("testValue"))).thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().setIfPresent("testKey", "testValue");

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).setIfPresent(eq("testApp:testKey"), eq("testValue"));
    }

    @Test
    void testOpsForValueDeleteWithPrefix() {
        when(reactiveValueOperations.delete(eq("testApp:testKey"))).thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().delete("testKey");

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).delete(eq("testApp:testKey"));
    }

    @Test
    void testOpsForValueIncrementWithPrefix() {
        when(reactiveValueOperations.increment(eq("testApp:testKey"))).thenReturn(Mono.just(1L));

        Mono<Long> result = prefixedTemplate.opsForValue().increment("testKey");

        StepVerifier.create(result)
                .expectNext(1L)
                .verifyComplete();

        verify(reactiveValueOperations).increment(eq("testApp:testKey"));
    }

    @Test
    void testOpsForValueAppendWithPrefix() {
        when(reactiveValueOperations.append(eq("testApp:testKey"), eq("value"))).thenReturn(Mono.just(10L));

        Mono<Long> result = prefixedTemplate.opsForValue().append("testKey", "value");

        StepVerifier.create(result)
                .expectNext(10L)
                .verifyComplete();

        verify(reactiveValueOperations).append(eq("testApp:testKey"), eq("value"));
    }

    @Test
    void testOpsForValueSetBitWithPrefix() {
        when(reactiveValueOperations.setBit(eq("testApp:testKey"), eq(1L), eq(true)))
                .thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().setBit("testKey", 1L, true);

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).setBit(eq("testApp:testKey"), eq(1L), eq(true));
    }

    @Test
    void testOpsForValueGetBitWithPrefix() {
        when(reactiveValueOperations.getBit(eq("testApp:testKey"), eq(1L)))
                .thenReturn(Mono.just(true));

        Mono<Boolean> result = prefixedTemplate.opsForValue().getBit("testKey", 1L);

        StepVerifier.create(result)
                .expectNext(true)
                .verifyComplete();

        verify(reactiveValueOperations).getBit(eq("testApp:testKey"), eq(1L));
    }

    @Test
    void testOpsForValueBitFieldWithPrefix() {
        BitFieldSubCommands subCommands = BitFieldSubCommands.create();

        when(reactiveValueOperations.bitField(eq("testApp:testKey"), eq(subCommands)))
                .thenReturn(Mono.just(List.of(1L, 2L)));

        Mono<List<Long>> result = prefixedTemplate.opsForValue().bitField("testKey", subCommands);

        StepVerifier.create(result)
                .expectNext(List.of(1L, 2L))
                .verifyComplete();

        verify(reactiveValueOperations).bitField(eq("testApp:testKey"), eq(subCommands));
    }
}
</div>

{% template  customCode.html %}
---
id: bca1a94d925fb0c89fbb97265e6e8da3
file: ValkeyBeanPostProcessorTest.java
---
{% endtemplate %}

**Mocking Dependencies:** We mock the dependencies for the ValkeyBeanPostProcessor and PrefixedReactiveRedisTemplate, including:

* Environment: Supplies configuration properties, such as spring.application.name.

* ReactiveRedisTemplate: Provides Redis operations that we’re customizing.

* ReactiveValueOperations: Represents operations specific to value manipulation in Redis.

* RedisSerializationContext and ReactiveRedisConnectionFactory: Required for ReactiveRedisTemplate instantiation but remain untested as their functionality is part of the core library.


**Setting Up the Mocks:** @BeforeEach initializes the mocks and configures environment to return "testApp" as the application name, which is used as the prefix.
We instantiate prefixedTemplate as a PrefixedReactiveRedisTemplate with "testApp" as the prefix, enabling all tests to validate prefixed behavior consistently.

**testPostProcessAfterInitializationWithReactiveRedisTemplate:** This test verifies that postProcessAfterInitialization correctly identifies ReactiveRedisTemplate instances and wraps them in PrefixedReactiveRedisTemplate.
The method returns a PrefixedReactiveRedisTemplate if the bean is a ReactiveRedisTemplate, confirming our custom configuration is applied correctly.

**testPostProcessAfterInitializationWithNonReactiveRedisTemplate: Ensures that non-ReactiveRedisTemplate beans are returned unmodified. This test is crucial to confirm ValkeyBeanPostProcessor only affects Redis templates and not other beans.**

**testApplyPrefixWithNonStringKey:** Validates that applyPrefix throws an IllegalArgumentException if the key is not a String. This enforces type consistency, ensuring only String keys are allowed.

**Key Operations Tests (e.g., testOpsForValueSetWithPrefix, testOpsForValueGetWithPrefix):**

These tests verify that the expected prefix (testApp) is prepended to keys for each operation:
Set and Get: Tests that the prefix is applied when setting or getting a key-value pair.
Set with Timeout: Ensures set operations with a timeout work as expected with prefixed keys.
MultiSet: Tests setting multiple key-value pairs at once, confirming all keys are prefixed.
SetIfAbsent and SetIfPresent: Ensures conditional set operations (only if absent/present) apply the prefix.
Each of these tests utilizes StepVerifier to assert the expected result of each operation (e.g., true for set and testValue for get).
Additional Operations:

Tests for delete, increment, append, setBit, getBit, and bitField confirm that even advanced or less common Redis operations apply the prefix.
These methods extend the comprehensiveness of the test suite by covering a range of operations that ReactiveRedisTemplate supports, validating prefix behavior across various Redis command types.
Assertions and Verifications:

Assertions: Each StepVerifier assertion validates the success of the operation, confirming that operations with prefixed keys execute correctly.
Verifications: After each test, verify checks that the mocked reactiveValueOperations received the correctly prefixed key (e.g., "testApp:testKey"), ensuring our applyPrefix logic is consistently applied across operations


## Deatailed Explanation

**PrefixedReactiveRedisTemplate:** Extends ReactiveRedisTemplate to intercept key operations and prepend the application-specific prefix. This pattern is a Decorator Pattern, allowing us to add functionality to ReactiveRedisTemplate without modifying its core behavior.

**BeanPostProcessor:** Spring’s BeanPostProcessor allows us to modify beans after their creation, making it ideal for adding custom functionality (like key prefixing) to the ReactiveRedisTemplate.

**@AutoConfigureAfter:** Specifies that this configuration should load after RedisReactiveAutoConfiguration to ensure all core Redis beans are available before applying custom configurations.

**SSL Customization with Peer Verification Disabled:** Valkey instances on Amazon may have SSL certificates that don’t fully match the hostnames, causing peer verification issues. To resolve this, we disable peer verification for SSL connections when spring.data.redis.ssl.enabled is set to true.
The LettuceClientConfigurationBuilderCustomizer bean configures SSL by calling .useSsl().disablePeerVerification(), allowing connections even if the SSL certificates differ from the expected host.
ValkeyBeanPostProcessor Bean:



## Manual Verfication


To verify, connect to Valkey using the Redis CLI:

```java
$ redis-cli --tls -h $HOST -p 6379 -user $username --pass $password
$ KEYS *testKey*
1) appID:testKey
$ GET appID:testKey
The key is stored with the expected appID: prefix.
```
---
layout: post
title: Daily Logs
image: https://unsplash.com/photos//download?w=437
thumb: https://unsplash.com/photos//download?w=437
author: 
tags: 
 - spring-boot
 - liquidbase
 - kaniko
category: blog
---

## Liquibase Clear Checksums for Testing

When working with Liquibase in Spring Boot applications, you might encounter checksum validation errors during testing. This happens when changesets are modified between runs.

### Configuration

```yaml
# application-local.yml
spring:
  liquibase:
    clear-checksums: true
```

### Important Notes

⚠️ **Never use in production** - this setting bypasses important safety checks that prevent accidental schema modifications.

```yaml
# Production configuration should be:
spring:
  liquibase:
    clear-checksums: false  # Default value
    fail-on-missing-sql-file: true
```

## Docker Hub Authentication in Jenkins with Kaniko

To avoid Docker Hub rate limits when building images with Kaniko in Jenkins pipelines:

### Jenkins Pipeline Implementation

```groovy
withCredentials([usernamePassword(credentialsId: 'docker', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
    container(name: 'kaniko', shell: '/busybox/sh') {
        sh """
            #!/busybox/sh            
            # Create Docker config directory
            mkdir -p /kaniko/.docker
            
            # Generate base64 encoded credentials
            AUTH=\$(echo -n \${DOCKER_USERNAME}:\${DOCKER_PASSWORD} | base64)
            
            # Create Docker config with authentication
            echo '{"auths":{"https://index.docker.io/v1/":{"auth":"'"\${AUTH}"'"}}}' > /kaniko/.docker/config.json
            
            # Verify Kaniko version
            /kaniko/executor version
            
            # Build and push image
            /kaniko/executor \\
                --cache=false \\
                --cache-dir=\$(pwd)/cache \\
                --context=dir://\$(pwd) \\
                --cache-repo ${config.deploy.getEcrRepoUrl()} \\
                --dockerfile ${build_image.name}/Dockerfile \\
                --destination ${config.deploy.getEcrRepoUrl()}:${imageTag}
        """
    }
}
```

### Key Components

1. **Credentials Management**: Uses Jenkins credentials store
2. **Base64 Encoding**: Encodes username:password for Docker auth
3. **Config File**: Creates `/kaniko/.docker/config.json` for authentication
4. **Rate Limit Avoidance**: Authenticated requests have higher rate limits

### Docker Hub Rate Limits

| Account Type | Pulls per 6 hours |
|--------------|------------------|
| Anonymous | 100 |
| Authenticated Free | 200 |
| Pro/Team | 5,000+ |

## Spring Boot Server vs Management Port Configuration

Understanding the difference between application and actuator endpoint ports:

### Application Server Port

```yaml
server:
  port: 8081
```

**Purpose**: Sets the port for your main application endpoints
- REST controllers
- Web pages
- Business logic APIs

### Management Server Port

```yaml
management:
  server:
    port: 9081
```

**Purpose**: Sets a separate port for Spring Boot Actuator endpoints
- Health checks (`/actuator/health`)
- Metrics (`/actuator/metrics`)
- Info (`/actuator/info`)

### Configuration Examples

```yaml
# Same port for both (default behavior)
server:
  port: 8080
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics

# Separate ports (recommended for production)
server:
  port: 8080
management:
  server:
    port: 9090
  endpoints:
    web:
      exposure:
        include: health,info,metrics
```

### Security Benefits of Separate Ports

```yaml
# Production configuration
server:
  port: 8080

management:
  server:
    port: 9090
    address: 127.0.0.1  # Only accessible locally
  endpoints:
    web:
      exposure:
        include: health,info
        exclude: env,beans,configprops  # Hide sensitive data
```

### Use Cases

| Scenario | Configuration | Benefits |
|----------|---------------|----------|
| **Development** | Same port (8080) | Simple setup, easy testing |
| **Production** | Separate ports | Security isolation, firewall rules |
| **Monitoring** | Management port only exposed to monitoring tools | Controlled access to metrics |

### Health Check Examples

```bash
# Application endpoint
curl http://localhost:8080/api/users

# Management endpoint (same port)
curl http://localhost:8080/actuator/health

# Management endpoint (separate port)
curl http://localhost:9090/actuator/health
```

**Best Practice**: Use separate ports in production to isolate management endpoints from application traffic and apply different security policies.
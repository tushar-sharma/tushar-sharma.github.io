---
layout: post
title: Daily Logs for Sep 8, 2025
image: https://unsplash.com/photos/QhKnu2mCtic/download?w=437
thumb: https://unsplash.com/photos/QhKnu2mCtic/download?w=437
author: tushar sharma
category: blog
tags:
 - letters
 - kafka
 - honda
---

Dear Vishi, dear logs for today.<!-- truncate_here -->

Dear Vishi, dear logs for today.

## Honda Safety Recall

If you ever got safety recall notice in mail, go to [Honda website](https://owners.honda.com/service-maintenance/recalls) and enter your VIN to verify.


## Kafka Listener in a Reactive Spring Java app 

In a traditional servlet-based Spring application, you can use `@KafkaListener` to consume messages from a topic:

```java
@KafkaListener(topics = "my-topic")
public void listen(String message) {
    // handle message
}

```

Spring manages this lifecycle automatically.

In a reactive application (WebFlux), there is no direct equivalent to @KafkaListener. Instead, you need to start your Kafka consumer explicitly. To understand where this fits, let’s look at Spring Boot’s lifecycle:

### Spring Boot Startup Order  

1. **ApplicationContext initialization**  
   - Spring container is created. No beans yet.  

2. **Bean creation and dependency injection**  
   - Beans are instantiated and wired.  

3. **`@PostConstruct` methods**  
   - Runs once after bean construction.  
   - Good for bean setup (initialize fields, validate config).  
   - Not for long-running tasks.  

4. **`SmartLifecycle.start()`**  
   - Invoked on beans implementing `SmartLifecycle`.  
   - Best for long-running processes (e.g., Kafka consumers).  
   - Supports clean start/stop hooks.  

5. **`CommandLineRunner` / `ApplicationRunner`**  
   - Runs after the context is loaded.  
   - Good for quick startup tasks (DB init, seed data).  
   - Not lifecycle-managed.  

6. **`ApplicationReadyEvent` is published**  
   - Fired when the app is ready.  

7. **Netty server fully ready**  
   - Reactive server now accepts requests.  

8. **`@EventListener(ApplicationReadyEvent.class)`**  
   - Runs after the app is fully ready.  
   - Safe for startup code.  
   - No clean shutdown support.  


### Using ApplicationReadyEvent

```java
@EventListener(ApplicationReadyEvent.class)
public void consumeKafkaMessage() {
    // start reactive Kafka consumer
}
```

**Pros**:

Runs after the application is ready.

**Cons**:
No built-in lifecycle management (no clean shutdown, no running status).


### Using SmartLifecycle

```java
@Service
public class KafkaService implements SmartLifecycle {

    private boolean running = false;

    @Override
    public void start() {
        // start Kafka consumer
        running = true;
    }

    @Override
    public void stop() {
        // stop Kafka consumer
        running = false;
    }

    @Override
    public boolean isRunning() {
        return running;
    }

    @Override
    public int getPhase() {
        return 0; // ordering relative to other lifecycle beans
    }
}

```

**Pros**:

Integrates with Spring lifecycle

Supports clean startup and shutdown

Exposes running state
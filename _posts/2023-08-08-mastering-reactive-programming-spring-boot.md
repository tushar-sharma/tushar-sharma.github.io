---
layout: post
date: 2023-08-08
title: Mastering Reactive Programming with Spring Boot
image: /img/
thumb: /img/
author: Tushar Sharma;
category: blog
published: false
---

.<!-- truncate_here -->

### Prequisites

* Java 11 or later

* Maven

* IDE (e.g. IntelliJ IDEA)

### Set up a Spring Boot project

Using the Spring Initializr:

* Go to [https://start.spring.io/](https://start.spring.io/)

* Choose Maven Project, Java, and the latest stable version of Spring Boot.

* Add the dependencies "Spring WebFlux" and "Reactor Test".

* Download the project and open it in your IDE.

### Basic Reactive Programming concept with Mono and Flux

In the `src/main/java` directory, create a new package called `tutorial`

Inside this package, create a new class called `ReactiveController`

```java
package tutorial;


import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

@RestController
public class ReactiveController{
    @GetMapping("/greetings")
    public Flux<String> getGreetings(){
        return Flux.just("Hello", "Hola", "Bonjour", "Namaste");
    }
}
```

Run the main class generated by Spring Boot (usually named {YourProjectName}Application.java). Once it's running, you can access http://localhost:8080/greetings to see your reactive endpoint in action.

Writing tests for our REST endpoint, in the `src/test/java/tutorial` directory, create a class named `ReactiveControllerTest`.

```java
package tutorial;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;


@WebFluxTest(ReactiveControllerTest.class)
public class ReactiveControllerTest{

    @Autowired
    private WebTestClient webTestClient;

    @Test
    public void testGetGreetings(){
        webTestClient.get()
            .uri("/greetings")
            .exchange()
            .expectStatus()
            .isOk()
            .expectBodyList(String.class)
            .hasSize(4);
    }
}
```

### Filter

Modify `ReactiveController's` getGreetings method:

```java
@GetMapping
public Flux<String> getGreetings() {
    return Flux.just("Hello", "Hola", "Bonjour", "Namaste")
               .filter(greeting -> !greeting.equals("Hola"));
}
```

Update the test in `ReactiveControllerTest`

```java
@Test
public void testGetGreetings(){
    webTestClient.get()
    .uri("/greetings")
    .exchange()
    .expectStatus().isOk()
    .expectBodyList(String.class)
    .hasSize(3)
    .contains("Hello", "Bonjour", "Namaste");
}
```
### Flatmap

The flatMap operation is used to transform the data contained within the reactive type (Mono in this case). It's like the map operation, but instead of just transforming the data, it also allows you to return a new reactive type.


The term "flatten" in this context doesn't refer to any structural simplification of a single Book object or its properties. Instead, it pertains to the transformation of a higher-order structure (like a collection or another reactive type) into a flattened, sequential stream.

When we say "flatten the List<Book> into a Flux<Book>", we're referring to the process of taking each individual Book element from the list and emitting it as an item in a reactive sequence.


Let's simulate two services: one that fetches user data and another that fetches user orders.

Create a `UserService` class:

```java
package tutorial;

import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Service
public class UserService {
    public Mono<String> findUser(String userId){
        return Mono.just("User: " + userId);
    }
}


```

And a OrderService class:

```java
package tutorial;

import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Service
public class OrderService {

    public Mono<String> findOrders(String userId) {
        return Mono.just("Orders for User: " + userId);
    }
}

```
Update your ReactiveController to use these services:


```java
@RestController
public class ReactiveController {
    @Autowired
    private UserService userService;

    @Autowired
    private OrderService orderService;

    @GetMapping("/user/{userId}/details")
    public Mono<String> getUserDetails(@PathVariable String userId){
        return userService.findUser(userId)
               .flatmap(user -> orderService.findOrders(userId))
               .map(order -> user + " | "  + order);
    }
}
```
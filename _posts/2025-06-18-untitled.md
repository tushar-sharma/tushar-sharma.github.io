---
layout: post
title: "Getting Started with Redis: Concepts, Commands, and Monitoring"
categories: [redis, nosql, database, python]
author: tushar sharma
---

## Introduction

[Redis](https://redis.io/) is a high-performance, in-memory NoSQL database widely used for caching, real-time analytics, and message brokering. It is a key-value store, meaning each unique key maps to a value, which can be a string, list, set, hash, or other data structures. Redis is designed for speed and simplicity, making it a popular choice for applications that require fast data access.

## Key Concepts

- **In-memory Database:** Redis stores all data in memory, enabling extremely fast read and write operations.
- **NoSQL:** Redis is schema-less and does not use tables or SQL queries.
- **Key-Value Store:** Data is stored as unique keys mapping to values. Only keys can be queried directly.

## Connecting to a Redis Cluster

To connect to a Redis cluster securely using the command line, you can use the `redis-cli` tool with TLS and authentication:

```bash
export username=<your-username>
export password=<your-password>
export hostname=<your-host>
redis-cli -h ${hostname} --user ${username} -a ${password} --tls
```

## Basic Redis Commands

Here are some essential Redis commands for working with keys and values:

```text
# Set a key-value pair
SET key1 value1

# Retrieve the value for a key
GET key1
# Output: value1

# Delete a key
DEL key1

# Working with lists
LPUSH myList value1
LPUSH myList value2
LRANGE myList 0 -1
# Output: ["value2", "value1"]
```

## Monitoring Redis Memory Usage

You can check the memory usage of your Redis instance with the `INFO MEMORY` command:

```text
info memory

used_memory:4647692880
used_memory_human:4.33G
maxmemory:5140907060
maxmemory_human:4.79G
```

## Subscribing to Keyspace Events

Redis supports publish/subscribe (pub/sub) messaging. You can subscribe to keyspace notifications to listen for changes to keys matching a pattern. For example, to listen for events on all keys in the `myApp` namespace:

```text
PSUBSCRIBE '__keyspace@*__:myApp:*'
```

## Monitoring Redis Events with Python

You can automate monitoring of Redis keyspace events using Python and the `redis` library. The following script connects to Redis, subscribes to a pattern, and logs events to both a file and the console:

```python
# filepath: /Users/SharmaT1/myFiles/randomwits/_posts/2025-06-18-untitled.md
import redis
import logging
from datetime import datetime
import json
import time
from logging.handlers import RotatingFileHandler
import socket
import sys

class RedisMonitor:
    def __init__(self):
        self.logger = self._setup_logger()
        self.redis_host = 'hostname'
        self.redis_username = 'username'
        self.redis_password = 'password'
        self.redis_port = 6379
        self.pattern = '__key*@*__:myApp:*'
        self.reconnect_delay = 5

    def _setup_logger(self):
        logger = logging.getLogger('redis_monitor')
        logger.setLevel(logging.INFO)
        handler = RotatingFileHandler('redis_monitor.log', maxBytes=100*1024*1024, backupCount=5)
        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        return logger

    def connect_redis(self):
        try:
            redis_client = redis.Redis(
                host=self.redis_host,
                port=self.redis_port,
                username=self.redis_username,
                password=self.redis_password,
                decode_responses=True,
                socket_keepalive=True,
                socket_timeout=300,
                socket_connect_timeout=300,
                ssl=True,
                ssl_cert_reqs=None
            )
            redis_client.ping()
            return redis_client
        except (redis.ConnectionError, socket.error) as e:
            self.logger.error(f"Failed to connect to Redis: {e}")
            return None

    def setup_subscription(self, redis_client):
        try:
            pubsub = redis_client.pubsub()
            pubsub.psubscribe(self.pattern)
            return pubsub
        except Exception as e:
            self.logger.error(f"Failed to setup subscription: {e}")
            return None

    def process_message(self, message):
        if message and message['type'] == 'pmessage':
            event = {
                'timestamp': datetime.now().isoformat(),
                'channel': message['channel'],
                'pattern': message['pattern'],
                'type': message['type'],
                'data': message['data']
            }
            self.logger.info(json.dumps(event))

    def run(self):
        while True:
            try:
                self.logger.info("Attempting to connect to Redis...")
                redis_client = self.connect_redis()
                if redis_client is None:
                    raise redis.ConnectionError("Failed to establish Redis connection")
                if redis_client.ping():
                    print(f"Connection successful to {self.redis_host}")
                pubsub = self.setup_subscription(redis_client)
                if pubsub is None:
                    raise Exception("Failed to setup subscription")
                self.logger.info(f"Successfully connected and monitoring pattern: {self.pattern}")
                for message in pubsub.listen():
                    self.process_message(message)
            except (redis.ConnectionError, socket.error) as e:
                self.logger.error(f"Connection error: {e}")
                self.logger.info(f"Retrying in {self.reconnect_delay} seconds...")
                time.sleep(self.reconnect_delay)
            except KeyboardInterrupt:
                self.logger.info("Received shutdown signal. Cleaning up...")
                if 'pubsub' in locals():
                    pubsub.punsubscribe()
                if 'redis_client' in locals():
                    redis_client.close()
                sys.exit(0)
            except Exception as e:
                self.logger.exception(f"Unexpected error: {e}")
                time.sleep(self.reconnect_delay)

if __name__ == "__main__":
    monitor = RedisMonitor()
    monitor.run()
```

**Sample Output:**

```text
2025-06-18 14:18:17,796 - INFO - {"timestamp": "2025-06-18T14:18:17.795951", "channel": "__keyspace@0__:myApp:test1", "pattern": "__key*@*__:myApp:*", "type": "pmessage", "data": "set"}
2025-06-18 14:32:25,326 - INFO - {"timestamp": "2025-06-18T14:32:25.325818", "channel": "__keyspace@0__:myApp:test2", "pattern": "__key*@*__:myApp:*", "type": "pmessage", "data": "set"}
```

## Conclusion

Redis is a powerful tool for fast data storage and real-time event monitoring. With simple commands and robust pub/sub capabilities, it is well-suited for modern applications that require speed and
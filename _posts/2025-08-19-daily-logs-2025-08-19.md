---
layout: post
title: Daily Logs for Aug 19, 2025
image: https://unsplash.com/photos//download?w=437
thumb: https://unsplash.com/photos//download?w=437
author: tushar sharma
category: blog
tags:
 - git
 - java
 - webflux
 - spring
---

## Git Branch Management

### Viewing Remote Branches

To see all remote branches in a Git repository:

```bash 
git branch -r
```

This displays all remote tracking branches, showing what branches exist on the remote repository.

### Searching for Specific Branches

To search for a specific branch pattern:

```bash 
git branch -r | grep x 
```

This filters remote branches containing 'x' in their name. You can also use more specific patterns:

```bash
# Search for feature branches
git branch -r | grep feature/

# Search case-insensitively
git branch -r | grep -i hotfix
```

### Additional Useful Git Branch Commands

```bash
# Show both local and remote branches
git branch -a

# Show branch details with latest commit
git branch -rv

# Search local branches
git branch | grep pattern
```

## Spring WebFlux WebClient: API Communication Patterns

Spring WebClient is the reactive equivalent of RestTemplate, designed for non-blocking HTTP requests in reactive applications.

### Basic Response Retrieval

The most straightforward approach uses `.retrieve()` for simple success scenarios:

```java
public Mono<DataDTO> getData(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class);
}
```

### Advanced Response Handling with Exchange

For more control over the response, use `.exchangeToMono()`:

```java
public Mono<DataDTO> getData(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(DataDTO.class);
            } else {
                return response.createException().flatMap(Mono::error);
            }
        });
}
```

### When to Use Each Approach

| Method | Use Case | Benefits |
|--------|----------|----------|
| `.retrieve()` | Simple success/error handling | Clean, concise code |
| `.exchangeToMono()` | Custom status code handling | Full response control |

### Working with Generic Types

For complex generic types, use `ParameterizedTypeReference`:

```java
public Mono<List<DataDTO>> getDataList() {
    return this.webClient
        .get()
        .uri("/data")
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference<List<DataDTO>>() {});
}
```

### Type Safety Considerations

While `ParameterizedTypeReference` handles generics at runtime, it has limitations:

```java
// Type-safe approach (preferred)
public Mono<DataDTO> getData(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class)
        .onErrorMap(WebClientResponseException.class, ex -> 
            new DataNotFoundException("Data not found for id: " + id));
}

// Less type-safe with ParameterizedTypeReference
public Mono<DataDTO> getDataUnsafe(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference<DataDTO>() {});
        // Compiler can't verify DataDTO structure at compile time
}
```

**Key Issue**: `ParameterizedTypeReference` bypasses compile-time type checking. If the JSON payload structure changes, you won't catch the mismatch until runtime, potentially causing `ClassCastException` or deserialization failures.

### Best Practices

1. **Use `.retrieve()`** for straightforward cases
2. **Use `.exchangeToMono()`** when you need custom error handling
3. **Prefer direct class references** over `ParameterizedTypeReference` when possible
4. **Always handle errors gracefully** in
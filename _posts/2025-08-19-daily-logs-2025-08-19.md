---
layout: post
title: Daily Logs for Aug 19, 2025
image: https://unsplash.com/photos//download?w=437
thumb: https://unsplash.com/photos//download?w=437
author: tushar sharma
category: blog
published: false
tags:
 - git
 - java
 - webflux
 - spring
---

## Git Branch Management

### Viewing Remote Branches

To see all remote branches in a Git repository:

```bash 
git branch -r
```

This displays all remote tracking branches, showing what branches exist on the remote repository.

### Searching for Specific Branches

To search for a specific branch pattern:

```bash 
git branch -r | grep x 
```

This filters remote branches containing 'x' in their name. You can also use more specific patterns:

```bash
# Search for feature branches
git branch -r | grep feature/

# Search case-insensitively
git branch -r | grep -i hotfix
```

### Additional Useful Git Branch Commands

```bash
# Show both local and remote branches
git branch -a

# Show branch details with latest commit
git branch -rv

# Search local branches
git branch | grep pattern
```

## Spring WebFlux WebClient: API Communication Patterns

Spring WebClient is the reactive equivalent of RestTemplate, designed for non-blocking HTTP requests in reactive applications.

### Basic Response Retrieval

The most straightforward approach uses `.retrieve()` for simple success scenarios:

```java
public Mono<DataDTO> getData(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class);
}
```

### Advanced Response Handling with Exchange

For more control over the response, use `.exchangeToMono()`:

```java
public Mono<DataDTO> getData(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(DataDTO.class);
            } else {
                return response.createException().flatMap(Mono::error);
            }
        });
}
```

### When to Use Each Approach

| Method | Use Case | Benefits |
|--------|----------|----------|
| `.retrieve()` | Simple success/error handling | Clean, concise code |
| `.exchangeToMono()` | Custom status code handling | Full response control |

### Working with Generic Types

For complex generic types, use `ParameterizedTypeReference`:

```java
public Mono<List<DataDTO>> getDataList() {
    return this.webClient
        .get()
        .uri("/data")
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference<List<DataDTO>>() {});
}
```

### Understanding Type Tokens vs Super Type Tokens

The choice between `DataDTO.class` and `ParameterizedTypeReference<DataDTO>()` relates to fundamental Java type system concepts:

#### Type Tokens for Simple Types

A **Type Token** captures reifiable types (types known at runtime):

```java
// Type Token - works because DataDTO.class is reifiable
public Mono<DataDTO> getUser(String id) {
    return webClient.get()
        .uri("/users/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class);  // ← Type Token
}
```

#### Super Type Tokens for Generic Types

A **Super Type Token** captures non-reifiable generic types using anonymous classes:

```java
// Super Type Token - needed because List<DataDTO> is not reifiable
public Mono<List<DataDTO>> getUserList() {
    return webClient.get()
        .uri("/users")
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference<List<DataDTO>>() {});
        //                                                            ^^
        //                                                   Anonymous class!
}

// This won't work due to type erasure:
// .bodyToMono(List<DataDTO>.class)  // ← Compilation error
```

#### The Anonymous Class Magic

When you write `new ParameterizedTypeReference<List<DataDTO>>() {}`, the compiler generates:

```java
// Compiler-generated anonymous subclass
class AnonymousParameterizedTypeReference extends ParameterizedTypeReference<List<DataDTO>> {
    // List<DataDTO> is preserved here - no type erasure!
}
```

### When Each Approach is Needed

```java
// ✅ Use Type Token for simple types
Mono<String> name = webClient.get().retrieve().bodyToMono(String.class);
Mono<DataDTO> user = webClient.get().retrieve().bodyToMono(DataDTO.class);

// ✅ Use Super Type Token for generic collections
Mono<List<DataDTO>> users = webClient.get().retrieve()
    .bodyToMono(new ParameterizedTypeReference<List<DataDTO>>() {});

Mono<Map<String, DataDTO>> userMap = webClient.get().retrieve()
    .bodyToMono(new ParameterizedTypeReference<Map<String, DataDTO>>() {});

// ⚠️ Super Type Token limitations - these won't work:
// new ParameterizedTypeReference<T>() {}              // T unknown at compile time
// new ParameterizedTypeReference<List<T>>() {}        // T unknown at compile time
// new ParameterizedTypeReference<List<? extends Number>>() {} // Wildcards not supported
```

### Reactive Alternative for Collections

For WebFlux, consider using `bodyToFlux()` instead of collections:

```java
// Instead of Mono<List<DataDTO>>
public Flux<DataDTO> getUsersReactive() {
    return webClient.get()
        .uri("/users")
        .retrieve()
        .bodyToFlux(DataDTO.class);  // ← Simple Type Token, returns Flux<DataDTO>
}

// Benefits: streaming, backpressure, memory efficiency
```

### The Real Type Safety Issue

The "type safety" concern isn't about compile vs runtime - it's about API contract changes:

```java
// Both approaches fail if API contract changes
// API changes from: {"name": "John"} to {"fullName": "John Doe"}

// Type Token approach
Mono<DataDTO> user1 = webClient.get().retrieve().bodyToMono(DataDTO.class);
// ← Still fails at runtime if DataDTO.name doesn't match API

// Super Type Token approach  
Mono<DataDTO> user2 = webClient.get().retrieve()
    .bodyToMono(new ParameterizedTypeReference<DataDTO>() {});
// ← Also fails at runtime for same reason
```

### Better Runtime Safety Strategies

```java
// 1. Defensive deserialization with validation
public Mono<DataDTO> getDataSafely(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class)
        .doOnNext(this::validateDto)  // Custom validation
        .onErrorMap(JsonProcessingException.class, ex -> 
            new ApiContractException("API response format changed", ex));
}

// 2. Use JsonNode for flexible parsing
public Mono<DataDTO> getDataFlexibly(String id) {
    return this.webClient
        .get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(JsonNode.class)
        .map(this::convertToDto)  // Custom mapping with fallbacks
        .onErrorResume(ex -> Mono.just(getDefaultDto()));
}
```

### Best Practices

```java
// 1. Use Type Tokens for simple types
Mono<DataDTO> simpleCase = webClient.get().retrieve().bodyToMono(DataDTO.class);

// 2. Use Super Type Tokens only when you need generic collections
Mono<List<DataDTO>> collectionCase = webClient.get().retrieve()
    .bodyToMono(new ParameterizedTypeReference<List<DataDTO>>() {});

// 3. Consider Flux for reactive collections
Flux<DataDTO> reactiveCase = webClient.get().retrieve().bodyToFlux(DataDTO.class);

// 4. Add validation for external API resilience
public Mono<DataDTO> getDataWithValidation(String id) {
    return webClient.get()
        .uri("/data/{id}", id)
        .retrieve()
        .bodyToMono(DataDTO.class)
        .doOnNext(this::validateApiContract)
        .onErrorMap(JsonProcessingException.class, ex -> 
            new ApiContractException("API response format changed", ex));
}
```

**Bottom Line**: Use Type Tokens (`Class<T>`) for simple types, Super Type Tokens (`ParameterizedTypeReference<T>`) for generic collections, and always validate external API contracts regardless of
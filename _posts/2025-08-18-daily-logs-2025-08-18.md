---
layout: post
title: Daily Logs for Aug 18, 2025
image: https://unsplash.com/photos//download?w=437
thumb: https://unsplash.com/photos//download?w=437
author: tushar sharma
category: blog
tags: 
  - java
  - kafka
  - testcontainers
  - identity providers
published: false
---

<!-- truncate_here -->

## Debugging Reactive Kafka Consumer Properties in Spring Boot

When working with Reactive Kafka in Spring Boot, it's often useful to inspect the actual configuration properties applied to your consumer.

```java
@EventListener(ApplicationReadyEvent.class)
public void logKafkaConsumerProperties() {
    var consumer = reactiveKafkaConsumerTemplate
        .receiverOptions()
        .consumerProperties();
    
    log.info("Kafka consumer properties: {}", consumer);
    
    // Log specific important properties
    log.info("Auto offset reset: {}", consumer.get("auto.offset.reset"));
    log.info("Group ID: {}", consumer.get("group.id"));
    log.info("Bootstrap servers: {}", consumer.get("bootstrap.servers"));
}
```

### Key Properties

- **`auto.offset.reset`**: Controls behavior when no initial offset exists (`earliest`, `latest`, `none`)
- **`group.id`**: Consumer group identifier for load balancing
- **`bootstrap.servers`**: Kafka broker connection endpoints
- **`key.deserializer`** and **`value.deserializer`**: Deserialization strategy
- **`session.timeout.ms`**: Consumer heartbeat timeout
- **`max.poll.records`**: Maximum records returned in a single poll

### Alternative Approach for ReactiveKafkaConsumerTemplate

If you're using `ReactiveKafkaConsumerTemplate` directly, you can also access properties through the receiver options:

```java
@EventListener(ApplicationReadyEvent.class)
public void logReactiveKafkaConfig() {
    var receiverOptions = reactiveKafkaConsumerTemplate.receiverOptions();
    
    log.info("Consumer properties: {}", receiverOptions.consumerProperties());
    log.info("Subscription topics: {}", receiverOptions.subscriptionTopics());
    log.info("Assignment listeners: {}", receiverOptions.assignmentListeners().size());
}
```


## Understanding Identity Providers and OAuth2 Authorization Servers

Identity Providers (IdPs) are specialized services that manage user authentication and authorization. Popular providers like Auth0, Okta, and Entra (formerly Azure AD) implement the OAuth2 protocol by providing robust authorization servers.

### What is an Identity Provider?

An Identity Provider is a service that:
- **Authenticates users** (verifies who they are)
- **Authorizes access** (determines what they can do)
- **Issues tokens** for secure API access
- **Manages user identities** centrally

### OAuth2 Authorization Server Components

These identity providers act as OAuth2 authorization servers, implementing key endpoints:

```bash
http
# Authorization endpoint - where users are redirected to login
GET https://your-domain.auth0.com/authorize?
    response_type=code&
    client_id=YOUR_CLIENT_ID&
    redirect_uri=YOUR_CALLBACK_URL&
    scope=openid profile email

# Token endpoint - where applications exchange authorization codes for tokens
POST https://your-domain.auth0.com/oauth/token
Content-Type: application/json

{
  "grant_type": "authorization_code",
  "client_id": "YOUR_CLIENT_ID",
  "client_secret": "YOUR_CLIENT_SECRET",
  "code": "AUTHORIZATION_CODE",
  "redirect_uri": "YOUR_CALLBACK_URL"
}
```

### Popular Identity Providers

| Provider | Strengths | Use Cases |
|----------|-----------|-----------|
| **Auth0** | Developer-friendly, extensive customization | Startups, custom applications |
| **Okta** | Enterprise features, strong compliance | Large organizations, B2B |
| **Entra ID** | Microsoft ecosystem integration | Office 365, Azure-based apps |

### Benefits of Using Identity Providers

- **Security**: Professional-grade security implementations
- **Compliance**: Built-in GDPR, SOC2, HIPAA compliance
- **Scalability**: Handle millions of users without infrastructure concerns
- **Features**: MFA, SSO, social logins out of the box

These providers abstract the complexity of OAuth2 implementation, allowing developers to focus on application logic rather than authentication infrastructure.

## Ryuk and the TestContainers

It's like a garbage collector for containers.

When you start a Testcontainer (e.g., MongoDB, PostgreSQL), here's what happens behind the scenes:

```bash
1. Testcontainers starts Ryuk container
2. Ryuk binds to the Docker host (via /var/run/docker.sock)
3. Your test starts a mongo container
4. Testcontainers labels that container with a unique session ID
5. Ryuk watches for containers with that label
6. When the JVM exits (test ends), Ryuk kills and removes all labeled containers
```
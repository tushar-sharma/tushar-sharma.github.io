---
layout: post
title: Daily Logs for Aug 18, 2025
image: https://unsplash.com/photos/Qxm4RUNPCyg/download?w=437
thumb: https://unsplash.com/photos/Qxm4RUNPCyg/download?w=437
author: tushar sharma
category: blog
tags: 
  - java
  - kafka
  - testcontainers
published: false
---

Dear Vishi, my logs for today.<!-- truncate_here -->

Dear Vishi, my logs for today


## Reactive Kafka Consumer Properties in Spring Boot

How to print configuration properties applied to the consumer?


```java
@EventListener(ApplicationReadyEvent.class)
public void logKafkaConsumerProperties() {
    var consumer = reactiveKafkaConsumerTemplate
        .receiverOptions()
        .consumerProperties();
    
    log.info("Kafka consumer properties: {}", consumer);
    
    // Log specific important properties
    log.info("Auto offset reset: {}", consumer.get("auto.offset.reset"));
    log.info("Group ID: {}", consumer.get("group.id"));
    log.info("Bootstrap servers: {}", consumer.get("bootstrap.servers"));
}
```

### Key Properties

- **`auto.offset.reset`**: Controls behavior when no initial offset exists (`earliest`, `latest`, `none`)
- **`group.id`**: Consumer group identifier for load balancing
- **`bootstrap.servers`**: Kafka broker connection endpoints
- **`key.deserializer`** and **`value.deserializer`**: Deserialization strategy
- **`session.timeout.ms`**: Consumer heartbeat timeout
- **`max.poll.records`**: Maximum records returned in a single poll

### Alternative Approach for ReactiveKafkaConsumerTemplate

If you're using `ReactiveKafkaConsumerTemplate` directly, you can also access properties through the receiver options:

```java
@EventListener(ApplicationReadyEvent.class)
public void logReactiveKafkaConfig() {
    var receiverOptions = reactiveKafkaConsumerTemplate.receiverOptions();
    
    log.info("Consumer properties: {}", receiverOptions.consumerProperties());
    log.info("Subscription topics: {}", receiverOptions.subscriptionTopics());
    log.info("Assignment listeners: {}", receiverOptions.assignmentListeners().size());
}
```


## Ryuk and the TestContainers

It's like a garbage collector for containers.

When you start a Testcontainer (e.g., MongoDB, PostgreSQL), here's what happens behind the scenes:

```bash
1. Testcontainers starts Ryuk container
2. Ryuk binds to the Docker host (via /var/run/docker.sock)
3. Your test starts a mongo container
4. Testcontainers labels that container with a unique session ID
5. Ryuk watches for containers with that label
6. When the JVM exits (test ends), Ryuk kills and removes all labeled containers
```